/*
 * generated by Xtext 2.19.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.myDsl.Button;
import org.xtext.example.mydsl.myDsl.Checkbox;
import org.xtext.example.mydsl.myDsl.CheckboxChoice;
import org.xtext.example.mydsl.myDsl.Container;
import org.xtext.example.mydsl.myDsl.ContainerReference;
import org.xtext.example.mydsl.myDsl.Domainmodel;
import org.xtext.example.mydsl.myDsl.Frame;
import org.xtext.example.mydsl.myDsl.Label;
import org.xtext.example.mydsl.myDsl.Layout;
import org.xtext.example.mydsl.myDsl.MyDslPackage;
import org.xtext.example.mydsl.myDsl.Position;
import org.xtext.example.mydsl.myDsl.Size;
import org.xtext.example.mydsl.myDsl.Text;
import org.xtext.example.mydsl.myDsl.Textfield;
import org.xtext.example.mydsl.services.MyDslGrammarAccess;

@SuppressWarnings("all")
public class MyDslSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private MyDslGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == MyDslPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case MyDslPackage.BUTTON:
				sequence_Button(context, (Button) semanticObject); 
				return; 
			case MyDslPackage.CHECKBOX:
				sequence_Checkbox(context, (Checkbox) semanticObject); 
				return; 
			case MyDslPackage.CHECKBOX_CHOICE:
				sequence_CheckboxChoice(context, (CheckboxChoice) semanticObject); 
				return; 
			case MyDslPackage.CONTAINER:
				sequence_Container(context, (Container) semanticObject); 
				return; 
			case MyDslPackage.CONTAINER_REFERENCE:
				sequence_ContainerReference(context, (ContainerReference) semanticObject); 
				return; 
			case MyDslPackage.DOMAINMODEL:
				sequence_Domainmodel(context, (Domainmodel) semanticObject); 
				return; 
			case MyDslPackage.FRAME:
				sequence_Frame(context, (Frame) semanticObject); 
				return; 
			case MyDslPackage.LABEL:
				sequence_Label(context, (Label) semanticObject); 
				return; 
			case MyDslPackage.LAYOUT:
				sequence_Layout(context, (Layout) semanticObject); 
				return; 
			case MyDslPackage.POSITION:
				sequence_Position(context, (Position) semanticObject); 
				return; 
			case MyDslPackage.SIZE:
				sequence_Size(context, (Size) semanticObject); 
				return; 
			case MyDslPackage.TEXT:
				sequence_Text(context, (Text) semanticObject); 
				return; 
			case MyDslPackage.TEXTFIELD:
				sequence_Textfield(context, (Textfield) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     GuiElement returns Button
	 *     Button returns Button
	 *
	 * Constraint:
	 *     (name=ID size=Size? text=Text)
	 */
	protected void sequence_Button(ISerializationContext context, Button semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CheckboxChoice returns CheckboxChoice
	 *
	 * Constraint:
	 *     choice=ID
	 */
	protected void sequence_CheckboxChoice(ISerializationContext context, CheckboxChoice semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CHECKBOX_CHOICE__CHOICE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CHECKBOX_CHOICE__CHOICE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCheckboxChoiceAccess().getChoiceIDTerminalRuleCall_0_0(), semanticObject.getChoice());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GuiElement returns Checkbox
	 *     Checkbox returns Checkbox
	 *
	 * Constraint:
	 *     (name=ID size=Size? choice=CheckboxChoice)
	 */
	protected void sequence_Checkbox(ISerializationContext context, Checkbox semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ContainerReference returns ContainerReference
	 *     GuiElement returns ContainerReference
	 *
	 * Constraint:
	 *     (referenceName=ID name=ID)
	 */
	protected void sequence_ContainerReference(ISerializationContext context, ContainerReference semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.CONTAINER_REFERENCE__REFERENCE_NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.CONTAINER_REFERENCE__REFERENCE_NAME));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.GUI_ELEMENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.GUI_ELEMENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getContainerReferenceAccess().getReferenceNameIDTerminalRuleCall_0_0(), semanticObject.getReferenceName());
		feeder.accept(grammarAccess.getContainerReferenceAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Container
	 *     Container returns Container
	 *
	 * Constraint:
	 *     (containerName=ID size=Size? layout=Layout? guielements+=GuiElement*)
	 */
	protected void sequence_Container(ISerializationContext context, Container semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Domainmodel returns Domainmodel
	 *
	 * Constraint:
	 *     elements+=Type+
	 */
	protected void sequence_Domainmodel(ISerializationContext context, Domainmodel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Type returns Frame
	 *     Frame returns Frame
	 *
	 * Constraint:
	 *     (name=ID size=Size? guielements+=GuiElement*)
	 */
	protected void sequence_Frame(ISerializationContext context, Frame semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GuiElement returns Label
	 *     Label returns Label
	 *
	 * Constraint:
	 *     (name=ID size=Size? text=Text)
	 */
	protected void sequence_Label(ISerializationContext context, Label semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Layout returns Layout
	 *
	 * Constraint:
	 *     layout=ID
	 */
	protected void sequence_Layout(ISerializationContext context, Layout semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.LAYOUT__LAYOUT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.LAYOUT__LAYOUT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLayoutAccess().getLayoutIDTerminalRuleCall_1_0(), semanticObject.getLayout());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Position returns Position
	 *
	 * Constraint:
	 *     (posX=INT posY=INT)
	 */
	protected void sequence_Position(ISerializationContext context, Position semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POSITION__POS_X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POSITION__POS_X));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.POSITION__POS_Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.POSITION__POS_Y));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPositionAccess().getPosXINTTerminalRuleCall_0_0(), semanticObject.getPosX());
		feeder.accept(grammarAccess.getPositionAccess().getPosYINTTerminalRuleCall_2_0(), semanticObject.getPosY());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Size returns Size
	 *
	 * Constraint:
	 *     (width=INT height=INT)
	 */
	protected void sequence_Size(ISerializationContext context, Size semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SIZE__WIDTH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SIZE__WIDTH));
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.SIZE__HEIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.SIZE__HEIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSizeAccess().getWidthINTTerminalRuleCall_0_0(), semanticObject.getWidth());
		feeder.accept(grammarAccess.getSizeAccess().getHeightINTTerminalRuleCall_2_0(), semanticObject.getHeight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Text returns Text
	 *
	 * Constraint:
	 *     text=ID
	 */
	protected void sequence_Text(ISerializationContext context, Text semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, MyDslPackage.Literals.TEXT__TEXT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, MyDslPackage.Literals.TEXT__TEXT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTextAccess().getTextIDTerminalRuleCall_1_0(), semanticObject.getText());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     GuiElement returns Textfield
	 *     Textfield returns Textfield
	 *
	 * Constraint:
	 *     (name=ID size=Size? text=Text)
	 */
	protected void sequence_Textfield(ISerializationContext context, Textfield semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
